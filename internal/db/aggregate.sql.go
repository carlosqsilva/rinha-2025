// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: aggregate.sql

package db

import (
	"context"
	"database/sql"
)

const aggregatePaymentsByProcessorAndDateRange = `-- name: AggregatePaymentsByProcessorAndDateRange :many
SELECT
  processor,
  COUNT(*) AS total_count,
  SUM(amount) AS total_amount
FROM
  payments
WHERE
  (requested_at >= ?1 OR ?1 IS NULL)
  AND (requested_at <= ?2 OR ?2 IS NULL)
GROUP BY
  processor
`

type AggregatePaymentsByProcessorAndDateRangeParams struct {
	From sql.NullInt64
	To   sql.NullInt64
}

type AggregatePaymentsByProcessorAndDateRangeRow struct {
	Processor   int64
	TotalCount  int64
	TotalAmount sql.NullFloat64
}

func (q *Queries) AggregatePaymentsByProcessorAndDateRange(ctx context.Context, arg AggregatePaymentsByProcessorAndDateRangeParams) ([]AggregatePaymentsByProcessorAndDateRangeRow, error) {
	rows, err := q.query(ctx, q.aggregatePaymentsByProcessorAndDateRangeStmt, aggregatePaymentsByProcessorAndDateRange, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregatePaymentsByProcessorAndDateRangeRow{}
	for rows.Next() {
		var i AggregatePaymentsByProcessorAndDateRangeRow
		if err := rows.Scan(&i.Processor, &i.TotalCount, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
